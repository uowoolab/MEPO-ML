import warnings
from datetime import date
from pathlib import Path

import numpy as np
import torch
from pymatgen.analysis.local_env import IsayevNN
from pymatgen.io.cif import CifParser
from torch_geometric.data import Data

from descriptors import get_dist_features, get_shell_features
from elements import atomic_properties
from model import MEPOML_GAT


def assign_single(src_path, dst_path, s, m):
    # read the input cif
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        cif_struct = CifParser(src_path).get_structures(primitive=False).pop()

    # generate new atomic labels
    n_atoms = len(cif_struct)
    atom_symbols = [atom.specie.symbol for atom in cif_struct]
    atom_labels = []
    label_counter = {element: 0 for element in set(atom_symbols)}
    for symbol in atom_symbols:
        label_counter[symbol] += 1
        atom_labels.append(f"{symbol}{label_counter[symbol]}")

    # generate the bond table as edges
    bond_table_func = IsayevNN(tol=0.5, allow_pathological=True).get_bonded_structure
    cif_bond_info = bond_table_func(cif_struct).as_dict()["graphs"]["adjacency"]
    bonds_ij = np.array(
        [
            (i, bond["id"], *bond["to_jimage"])
            for i, bonds in enumerate(cif_bond_info)
            for bond in bonds
        ]
    )
    bonds_ji = np.hstack([bonds_ij[:, [1, 0]], -bonds_ij[:, 2:]])
    bonds_full = np.vstack([bonds_ij, bonds_ji])
    edges = bonds_full[:, [0, 1]].T

    # generate and scale chemical descriptors as node features
    f_atom = np.array([atomic_properties[symbol] for symbol in atom_symbols])
    f_dist = get_dist_features(cif_struct, atom_symbols, n_atoms)
    f_shell = get_shell_features(bonds_full, f_atom, n_atoms)
    node_features = (np.hstack([f_atom, f_dist, f_shell]) - s["mean"]) / s["scale"]

    # predict charges using the model
    graph_data = Data(
        x=torch.tensor(node_features, dtype=torch.float).contiguous(),
        edge_index=torch.tensor(edges, dtype=torch.long).contiguous(),
    )
    charges = m(graph_data).flatten().numpy()

    # preambles for the new CIF
    cif_name = src_path.stem.removesuffix("_repeat")
    new_cif = f"""# Charges generated by MEPO-ML
data_{cif_name}
_audit_creation_date              {date.today().strftime("%Y-%m-%d")}
_audit_creation_method            MEPO-ML
_cell_length_a                    {round(cif_struct.lattice.a, 6):.6f}
_cell_length_b                    {round(cif_struct.lattice.b, 6):.6f}
_cell_length_c                    {round(cif_struct.lattice.c, 6):.6f}
_cell_angle_alpha                 {round(cif_struct.lattice.alpha, 6):.6f}
_cell_angle_beta                  {round(cif_struct.lattice.beta, 6):.6f}
_cell_angle_gamma                 {round(cif_struct.lattice.gamma, 6):.6f}
_cell_volume                      {round(cif_struct.lattice.volume, 6):.6f}
_symmetry_space_group_name_H-M    P1
_symmetry_Int_Tables_number       1
loop_
    _symmetry_equiv_pos_site_id
    _symmetry_equiv_pos_as_xyz
    1  x,y,z
loop_
    _atom_site_type_symbol
    _atom_site_label
    _atom_site_fract_x
    _atom_site_fract_y
    _atom_site_fract_z
    _atom_type_partial_charge
"""

    # compile all atomic information into a block of text for the new CIF
    symbol_width = len(max(atom_symbols, key=len))
    label_width = len(max(atom_labels, key=len))
    for symbol, label, frac, charge in zip(
        atom_symbols, atom_labels, cif_struct.frac_coords, charges
    ):
        new_cif += f"    {symbol:{symbol_width}}  {label:{label_width}}  "
        new_cif += "{:.6f}  {:.6f}  {:.6f}  ".format(*frac) + f"{charge:.6f}\n"

    dst_path.joinpath(cif_name + "_mepoml.cif").write_text(new_cif)


def main(src_str, dst_str):
    # check existence of source
    assert src_str, "No source of CIF(s) given"
    src_path = Path(src_str)
    assert src_path.exists(), f"{src_str} DOES NOT EXIST."

    # given destination, mkdir if does not exist
    if dst_str is not None:
        dst_path = Path(dst_str)
        if not dst_path.is_dir():
            dst_path.mkdir(parents=True)
            print(f"Created new folder: {dst_path}")
    else:
        print(
            "No destination folder set, new CIF(s) will be stored in the source folder."
        )

    # load scaler and model
    scaler = np.load("feature_scaler.npz")
    model_path = Path("mepoml_model.pt")
    model = MEPOML_GAT()
    model.load_state_dict(torch.load(model_path, map_location=torch.device("cpu")))
    model.eval()

    with torch.inference_mode():
        # assign charges for a single CIF
        if src_path.is_file():
            # store new CIF in the same folder of the source if no dst given
            if dst_str is None:
                assign_single(src_path, src_path.parent, scaler, model)
            else:
                assign_single(src_path, dst_path, scaler, model)
        else:
            from tqdm import tqdm

            # assign charges for all CIFs in src folder
            # currently only running in serial due to some issues
            # when using multiprocessing with pytorch models
            src_glob = list(src_path.glob("*.cif"))
            assert len(src_glob), f"No CIFs found in {src_path}"
            for cif_path in tqdm(
                src_glob, ncols=0, ascii=True, desc="Assignment progress:"
            ):
                if dst_str is None:
                    assign_single(cif_path, src_path, scaler, model)
                else:
                    assign_single(cif_path, dst_path, scaler, model)


if __name__ == "__main__":
    from argparse import ArgumentParser

    ap = ArgumentParser(
        description="Predict REPEAT charges and output to a new CIF file."
    )
    ap.add_argument(
        "--src",
        type=str,
        metavar="SRC_DIR",
        help="Source directory for batch predictions",
    )
    ap.add_argument(
        "--dst",
        type=str,
        metavar="DST_DIR",
        help="Destination directory for the output CIF file",
    )
    args = ap.parse_args()
    main(args.src, args.dst)
